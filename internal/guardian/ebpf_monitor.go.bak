
package guardian

import (
	"bytes"
	"encoding/binary"
	"errors"
	"fmt"
	"log"
	"strings"

	"github.com/cilium/ebpf"
	"github.com/cilium/ebpf/link"
	"github.com/cilium/ebpf/perf"
	"github.com/cilium/ebpf/rlimit"
)

// EBPFMonitor provides high-performance process monitoring via eBPF
// as an alternative to /proc polling.
type EBPFMonitor struct {
	objs      *ebpfObjects
	link      link.Link
	reader    *perf.Reader
	enabled   bool
	forbiddenApps []string
}

// ebpfObjects holds the loaded eBPF programs and maps.
// This will be generated by bpf2go (cilium/ebpf tooling).
type ebpfObjects struct {
	Programs ebpfPrograms
	Maps     ebpfMaps
}

type ebpfPrograms struct {
	TraceExec *ebpf.Program `ebpf:"trace_exec"`
}

type ebpfMaps struct {
	Events *ebpf.Map `ebpf:"events"`
}

// execEvent represents a process execution event captured by eBPF.
type execEvent struct {
	PID      uint32
	PPID     uint32
	Comm     [16]byte  // Process name (TASK_COMM_LEN)
	Filename [256]byte // Executable path
}

// NewEBPFMonitor creates a new eBPF-based process monitor.
func NewEBPFMonitor() (*EBPFMonitor, error) {
	// Remove resource limits for eBPF
	if err := rlimit.RemoveMemlock(); err != nil {
		return nil, fmt.Errorf("failed to remove memlock limit: %w", err)
	}

	m := &EBPFMonitor{
		forbiddenApps: loadForbiddenApps(),
	}

	// Load the compiled eBPF object
	if err := m.load(); err != nil {
		return nil, fmt.Errorf("failed to load eBPF program: %w", err)
	}

	return m, nil
}

// load compiles and loads the eBPF program from embedded bytecode.
func (m *EBPFMonitor) load() error {
	// eBPF program specification in Go
	// This creates a tracepoint on sched/sched_process_exec
	spec := &ebpf.CollectionSpec{
		Maps: map[string]*ebpf.MapSpec{
			"events": {
				Type:       ebpf.PerfEventArray,
				KeySize:    4,
				ValueSize:  4,
				MaxEntries: 128,
			},
		},
		Programs: map[string]*ebpf.ProgramSpec{
			"trace_exec": {
				Type:       ebpf.TracePoint,
				AttachType: ebpf.AttachTracePoint,
				AttachTo:   "sched/sched_process_exec",
				License:    "GPL",
				Instructions: m.buildBPFInstructions(),
			},
		},
	}

	// Load the spec into the kernel
	coll, err := ebpf.NewCollection(spec)
	if err != nil {
		return fmt.Errorf("failed to create eBPF collection: %w", err)
	}

	m.objs = &ebpfObjects{
		Programs: ebpfPrograms{
			TraceExec: coll.Programs["trace_exec"],
		},
		Maps: ebpfMaps{
			Events: coll.Maps["events"],
		},
	}

	// Attach to tracepoint
	tp, err := link.Tracepoint("sched", "sched_process_exec", m.objs.Programs.TraceExec, nil)
	if err != nil {
		coll.Close()
		return fmt.Errorf("failed to attach to tracepoint: %w", err)
	}
	m.link = tp

	// Create perf reader for events
	m.reader, err = perf.NewReader(m.objs.Maps.Events, 4096)
	if err != nil {
		tp.Close()
		coll.Close()
		return fmt.Errorf("failed to create perf reader: %w", err)
	}

	m.enabled = true
	log.Println("Guardian: eBPF process monitor initialized (tracepoint: sched/sched_process_exec)")
	return nil
}

// buildBPFInstructions generates the eBPF bytecode for process monitoring.
// This is a simplified inline implementation; production code would use bpf2go
// to compile from C and embed the bytecode.
func (m *EBPFMonitor) buildBPFInstructions() ebpf.Asm {
	return ebpf.Asm{
		// BPF program that captures exec events and writes to perf buffer
		// This is a minimal stub; full implementation would:
		// 1. Read task_struct from context
		// 2. Extract PID, PPID, comm, filename
		// 3. Write execEvent struct to perf buffer
		
		// For now, return a simple pass-through program
		// In production, use: //go:generate go run github.com/cilium/ebpf/cmd/bpf2go ...
		ebpf.Return().Op(ebpf.ReturnOp),
	}
}

// Start begins monitoring process execution events.
func (m *EBPFMonitor) Start() error {
	if !m.enabled {
		return errors.New("eBPF monitor not initialized")
	}

	go m.eventLoop()
	log.Println("Guardian: eBPF event loop started")
	return nil
}

// eventLoop continuously reads execution events from the eBPF perf buffer
// and terminates forbidden processes.
func (m *EBPFMonitor) eventLoop() {
	for {
		record, err := m.reader.Read()
		if err != nil {
			if errors.Is(err, perf.ErrClosed) {
				return
			}
			log.Printf("Guardian: eBPF read error: %v", err)
			continue
		}

		if record.LostSamples > 0 {
			log.Printf("Guardian: eBPF lost %d samples", record.LostSamples)
		}

		var event execEvent
		if err := binary.Read(bytes.NewReader(record.RawSample), binary.LittleEndian, &event); err != nil {
			log.Printf("Guardian: Failed to parse eBPF event: %v", err)
			continue
		}

		m.handleExecEvent(&event)
	}
}

// handleExecEvent processes a single execution event.
func (m *EBPFMonitor) handleExecEvent(event *execEvent) {
	comm := string(bytes.TrimRight(event.Comm[:], "\x00"))
	filename := string(bytes.TrimRight(event.Filename[:], "\x00"))

	commLower := strings.ToLower(comm)
	filenameLower := strings.ToLower(filename)

	for _, app := range m.forbiddenApps {
		appLower := strings.ToLower(app)
		if strings.Contains(commLower, appLower) || strings.Contains(filenameLower, appLower) {
			log.Printf("Guardian: ⚔️ [eBPF] Terminating forbidden process: %s (PID %d)", comm, event.PID)
			if err := sysOps.Kill(int(event.PID), 9); err != nil {
				log.Printf("Guardian: Failed to kill PID %d: %v", event.PID, err)
			}
			return
		}
	}
}

// Close stops the eBPF monitor and releases resources.
func (m *EBPFMonitor) Close() error {
	if !m.enabled {
		return nil
	}

	var errs []error

	if m.reader != nil {
		if err := m.reader.Close(); err != nil {
			errs = append(errs, fmt.Errorf("reader close: %w", err))
		}
	}

	if m.link != nil {
		if err := m.link.Close(); err != nil {
			errs = append(errs, fmt.Errorf("link close: %w", err))
		}
	}

	if m.objs != nil {
		if m.objs.Programs.TraceExec != nil {
			m.objs.Programs.TraceExec.Close()
		}
		if m.objs.Maps.Events != nil {
			m.objs.Maps.Events.Close()
		}
	}

	m.enabled = false

	if len(errs) > 0 {
		return fmt.Errorf("eBPF cleanup errors: %v", errs)
	}
	return nil
}

// IsEnabled returns whether the eBPF monitor is active.
func (m *EBPFMonitor) IsEnabled() bool {
	return m.enabled
}

// UpdateForbiddenApps refreshes the list of forbidden applications.
func (m *EBPFMonitor) UpdateForbiddenApps() {
	m.forbiddenApps = loadForbiddenApps()
	log.Printf("Guardian: eBPF monitor updated forbidden apps list (%d entries)", len(m.forbiddenApps))
}
